<div class="readme-block">
  <div>
    <style>
      @import url(/_upload/tpl/0c/d8/3288/template3288/css/github.css);
    </style>
    <h1 id="inputfile">INPUT file</h1>
    <h2 id="tableofcontents">Table of contents</h2>
    <h3 id="structureofthefilestructureofthefile">
      <a href="#structure-of-the-file">Structure of the file</a>
    </h3>
    <h3 id="listofkeywordslistofkeywords">
      <a href="#list-of-keywords">List of keywords</a>
    </h3>
    <ul>
      <li>
        <p><a href="#system-variables">System variables</a></p>
        <p>
          <a href="#suffix">suffix</a> | <a href="#ntype">ntype</a> |
          <a href="#calculation">calculation</a> |
          <a href="#symmetry">symmetry</a> | <a href="#kpar">kpar</a> |
          <a href="#bndpar">bndpar</a> | <a href="#latname">latname</a> |
          <a href="#init_wfc">init_wfc</a> | <a href="#init_chg">init_chg</a> |
          <a href="#init_vel">init_vel</a> | <a href="#nelec">nelec</a> |
          <a href="#tot_magnetization">tot_magnetization</a> |
          <a href="#dft_functional">dft_functional</a> |
          <a href="#pseudo_type">pseudo_type</a> |
          <a href="#pseudo_rcut">pseudo_rcut</a> |
          <a href="#pseudo_mesh">pseudo_mesh</a> |
          <a href="#mem_saver">mem_saver</a> |
          <a href="#diago_proc">diago_proc</a> |
          <a href="#nbspline">nbspline</a> | <a href="#kspacing">kspacing</a> |
          <a href="#min_dist_coef">min_dist_coef</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#variables-related-to-input-files"
            >Variables related to input files</a
          >
        </p>
        <p>
          <a href="#stru_file">stru_file</a> |
          <a href="#kpoint_file">kpoint_file</a> |
          <a href="#pseudo_dir">pseudo_dir</a> |
          <a href="#orbital_dir">orbital_dir</a> |
          <a href="#read_file_dir">read_file_dir</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#plane-wave-related-variables"
            >Plane wave related variables</a
          >
        </p>
        <p>
          <a href="#ecutwfc">ecutwfc</a> | <a href="#nx-ny-nz">nx,ny,nz</a> |
          <a href="#pw_seed">pw_seed</a> |
          <a href="#pw_diag_thr">pw_diag_thr</a> |
          <a href="#pw_diag_nmax">pw_diag_nmax</a> |
          <a href="#pw_diag_ndim">pw_diag_ndim</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#numerical-atomic-orbitals-related-variables"
            >Numerical atomic orbitals related variables</a
          >
        </p>
        <p>
          <a href="#nb2d">nb2d</a> | <a href="#lmaxmax">lmaxmax</a> |
          <a href="#lcao_ecut">lcao_ecut</a> | <a href="#lcao_dk">lcao_dk</a> |
          <a href="#lcao_dr">lcao_dr</a> | <a href="#lcao_rmax">lcao_rmax</a> |
          <a href="#search_radius">search_radius</a> |
          <a href="#search_pbc">search_pbc</a>
        </p>
      </li>
      <li>
        <p><a href="#electronic-structure">Electronic structure</a></p>
        <p>
          <a href="#basis_type">basis_type</a> |
          <a href="#ks_solver">ks_solver</a> | <a href="#nbands">nbands</a> |
          <a href="#nbands_istate">nbands_istate</a> |
          <a href="#nspin">nspin</a> | <a href="#occupations">occupations</a> |
          <a href="#smearing_method">smearing_method</a> |
          <a href="#smearing_sigma">smearing_sigma</a> |
          <a href="#mixing_type">mixing_type</a> |
          <a href="#mixing_beta">mixing_beta</a> |
          <a href="#mixing_ndim">mixing_ndim</a> |
          <a href="#mixing_gg0">mixing_gg0</a> |
          <a href="#gamma_only">gamma_only</a> | <a href="#printe">printe</a> |
          <a href="#scf_nmax">scf_nmax</a> | <a href="#scf_thr">scf_thr</a> |
          <a href="#chg_extrap">chg_extrap</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#electronic-structure-sdft">Electronic structure (SDFT)</a>
        </p>
        <p>
          <a href="#method_sto">method_sto</a> |
          <a href="#nbands_sto">nbands_sto</a> |
          <a href="#nche_sto">nche_sto</a> | <a href="#emin_sto">emin_sto</a> |
          <a href="#emax_sto">emax_sto</a> | <a href="#seed_sto">seed_sto</a> |
          <a href="#initsto_freq">initsto_freq</a>
        </p>
      </li>
      <li>
        <p><a href="#geometry-relaxation">Geometry relaxation</a></p>
        <p>
          <a href="#relax_nmax">relax_nmax</a> |
          <a href="#relax_method">relax_method</a> |
          <a href="#relax_cg_thr">relax_cg_thr</a> |
          <a href="#relax_bfgs_w1">relax_bfgs_w1</a> |
          <a href="#relax_bfgs_w2">relax_bfgs_w2</a> |
          <a href="#relax_bfgs_rmax">relax_bfgs_rmax</a> |
          <a href="#relax_bfgs_rmin">relax_bfgs_rmin</a> |
          <a href="#relax_bfgs_init">relax_bfgs_init</a> |
          <a href="#cal_force">cal_force</a> |
          <a href="#force_thr">force_thr</a> |
          <a href="#force_thr_ev">force_thr_ev</a> |
          <a href="#cal_stress">cal_stress</a> |
          <a href="#stress_thr">stress_thr</a> |
          <a href="#press1-press2-press3">press1, press2, press3</a> |
          <a href="#fixed_axes">fixed_axes</a> |
          <a href="#cell_factor">cell_factor</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#variables-related-to-output-information"
            >Variables related to output information</a
          >
        </p>
        <p>
          <a href="#out_force">out_force</a> | <a href="#out_mul">out_mul</a> |
          <a href="#out_freq_elec">out_freq_elec</a> |
          <a href="#out_freq_ion">out_freq_ion</a> |
          <a href="#out_chg">out_chg</a> | <a href="#out_pot">out_pot</a> |
          <a href="#out_dm">out_dm</a> | <a href="#out_wfc_pw">out_wfc_pw</a> |
          <a href="#out_wfc_r">out_wfc_r</a> |
          <a href="#out_wfc_lcao">out_wfc_lcao</a> |
          <a href="#out_dos">out_dos</a> | <a href="#out_band">out_band</a> |
          <a href="#out_proj_band">out_proj_band</a> |
          <a href="#out_stru">out_stru</a> |
          <a href="#out_level">out_level</a> |
          <a href="#out_alllog">out_alllog</a> |
          <a href="#out_mat_hs">out_mat_hs</a> |
          <a href="#out_mat_r">out_mat_r</a> |
          <a href="#out_mat_hs2">out_mat_hs2</a> |
          <a href="#out_element_info">out_element_info</a> |
          <a href="#restart_save">restart_save</a> |
          <a href="#restart_load">restart_load</a>
        </p>
      </li>
      <li>
        <p><a href="#density-of-states">Density of states</a></p>
        <p>
          <a href="#dos_edelta_ev">dos_edelta_ev</a> |
          <a href="#dos_sigma">dos_sigma</a> |
          <a href="#dos_scale">dos_scale</a> | <a href="#dos_nche">dos_nche</a>
        </p>
      </li>
      <li>
        <p><a href="#exact-exchange">Exact exchange</a> (Under tests)</p>
        <p>
          <a href="#exx_hybrid_type">exx_hybrid_type</a> |
          <a href="#exx_hybrid_alpha">exx_hybrid_alpha</a> |
          <a href="#exx_hse_omega">exx_hse_omega</a> |
          <a href="#exx_separate_loop">exx_separate_loop</a> |
          <a href="#exx_hybrid_step">exx_hybrid_step</a> |
          <a href="#exx_lambda">exx_lambda</a> |
          <a href="#exx_pca_threshold">exx_pca_threshold</a> |
          <a href="#exx_c_threshold">exx_c_threshold</a> |
          <a href="#exx_v_threshold">exx_v_threshold</a> |
          <a href="#exx_dm_threshold">exx_dm_threshold</a> |
          <a href="#exx_schwarz_threshold">exx_schwarz_threshold</a> |
          <a href="#exx_cauchy_threshold">exx_cauchy_threshold</a> |
          <a href="#exx_ccp_threshold">exx_ccp_threshold</a> |
          <a href="#exx_ccp_rmesh_times">exx_ccp_rmesh_times</a> |
          <a href="#exx_distribute_type">exx_distribute_type</a> |
          <a href="#exx_opt_orb_lmax">exx_opt_orb_lmax</a> |
          <a href="#exx_opt_orb_ecut">exx_opt_orb_ecut</a> |
          <a href="#exx_opt_orb_tolerence">exx_opt_orb_tolerence</a>
        </p>
      </li>
      <li>
        <p><a href="#molecular-dynamics">Molecular dynamics</a></p>
        <p>
          <a href="#md_type">md_type</a> | <a href="#md_nstep">md_nstep</a> |
          <a href="#md_ensolver">md_ensolver</a> |
          <a href="#md_restart">md_restart</a> | <a href="#md_dt">md_dt</a> |
          <a href="#md_t">md_t</a> | <a href="#md_dumpfreq">md_dumpfreq</a> |
          <a href="#md_restartfreq">md_restartfreq</a> |
          <a href="#md_seed">md_seed</a> | <a href="#md_tfreq">md_tfreq</a> |
          <a href="#md_mnhc">md_mnhc</a> | <a href="#lj_rcut">lj_rcut</a> |
          <a href="#lj_epsilon">lj_epsilon</a> |
          <a href="#lj_sigma">lj_sigma</a> |
          <a href="#msst_direction">msst_direction</a> |
          <a href="#msst_vel">msst_vel</a> | <a href="#msst_vis">msst_vis</a> |
          <a href="#msst_tscale">msst_tscale</a> |
          <a href="#msst_qmass">msst_qmass</a> | <a href="#md_damp">md_damp</a>
        </p>
      </li>
      <li>
        <p><a href="#vdw-correction">vdW correction</a></p>
        <p>
          <a href="#vdw_method">vdw_method</a> | <a href="#vdw_s6">vdw_s6</a> |
          <a href="#vdw_s8">vdw_s8</a> | <a href="#vdw_a1">vdw_a1</a> |
          <a href="#vdw_a2">vdw_a2</a> | <a href="#vdw_d">vdw_d</a> |
          <a href="#vdw_abc">vdw_abc</a> |
          <a href="#vdw_C6_file">vdw_C6_file</a> |
          <a href="#vdw_C6_unit">vdw_C6_unit</a> |
          <a href="#vdw_R0_file">vdw_R0_file</a> |
          <a href="#vdw_R0_unit">vdw_R0_unit</a> |
          <a href="#vdw_model">vdw_model</a> |
          <a href="#vdw_radius">vdw_radius</a> |
          <a href="#vdw_radius_unit">vdw_radius_unit</a> |
          <a href="#vdw_cn_radius">vdw_cn_radius</a> |
          <a href="#vdw_cn_radius_unit">vdw_cn_radius_unit</a> |
          <a href="#vdw_period">vdw_period</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#berry-phase-and-wannier90-interface"
            >Berry phase and wannier90 interface</a
          >
        </p>
        <p>
          <a href="#berry_phase">berry_phase</a> | <a href="#gdir">gdir</a> |
          <a href="#towannier90">towannier90</a> |
          <a href="#nnkpfile">nnkpfile</a> |
          <a href="#wannier_spin">wannier_spin</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#tddft-time-dependent-density-functional-theory"
            >TDDFT: time dependent density functional theory</a
          >
          (Under tests)
        </p>
        <p>
          <a href="#tddft">tddft</a> | <a href="#td_scf_thr">td_scf_thr</a> |
          <a href="#td_dt">td_dt</a> | <a href="#td_force_dt">td_force_dt</a> |
          <a href="#td_vext">td_vext</a> |
          <a href="#td_vext_dire">td_vext_dire</a> |
          <a href="#td_timescale">td_timescale</a> |
          <a href="#td_vexttype">td_vexttype</a> |
          <a href="#td_vextout">td_vextout</a> |
          <a href="#td_dipoleout">td_dipoleout</a> | <a href="#ocp">ocp</a> |
          <a href="#ocp_set">ocp_set</a>
        </p>
      </li>
      <li>
        <p><a href="#DFTU-correction">DFT+U correction</a> (Under tests)</p>
        <p>
          <a href="#dft_plus_u">dft_plus_u</a> |
          <a href="#orbital_corr">orbital_corr</a> |
          <a href="#hubbard_u">hubbard_u</a> | <a href="#hund_j">hund_j</a> |
          <a href="#yukawa_potential">yukawa_potential</a> |
          <a href="#omc">omc</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#variables-useful-for-debugging"
            >Variables useful for debugging</a
          >
        </p>
        <p>
          <a href="#nurse">nurse</a> | <a href="#t_in_h">t_in_h</a> |
          <a href="#vl_in_h">vl_in_h</a> | <a href="#vnl_in_h">vnl_in_h</a> |
          <a href="#test_force">test_force</a> |
          <a href="#test_stress">test_stress</a> | <a href="#colour">colour</a>
        </p>
      </li>
      <li>
        <p><a href="#deepks">DeePKS</a></p>
        <p>
          <a href="#deepks_out_labels">deepks_out_labels</a> |
          <a href="#deepks_descriptor_lmax">deepks_descriptor_lmax</a> |
          <a href="#deepks_scf">deepks_scf</a> |
          <a href="#deepks_model">deepks_model</a>
        </p>
      </li>
      <li>
        <p>
          <a href="#electric-field-and-dipole-correction"
            >Electric field and dipole correction</a
          >
        </p>
        <p>
          <a href="#efield_flag">efield_flag</a> |
          <a href="#dip_cor_flag">dip_cor_flag</a> |
          <a href="#efield_dir">efield_dir</a> |
          <a href="#efield_pos_max">efield_pos_max</a> |
          <a href="#efield_pos_dec">efield_pos_dec</a> |
          <a href="#efield_amp">efield_amp </a>
        </p>
      </li>
      <li>
        <p>
          <a href="#electronic-conductivities">Electronic conductivities</a>
        </p>
        <p>
          <a href="#cal_cond">cal_cond</a> |
          <a href="#cond_nche">cond_nche</a> | <a href="#cond_dw">cond_dw</a> |
          <a href="#cond_wcut">cond_wcut</a> |
          <a href="#cond_wenlarge">cond_wenlarge</a> |
          <a href="#cond_fwhm">cond_fwhm </a>
        </p>
      </li>
      <li>
        <p><a href="#implicit-solvation-model">Implicit solvation model</a></p>
        <p>
          <a href="#imp_sol">imp_sol</a> | <a href="#eb_k">eb_k</a> |
          <a href="#tau">tau</a> | <a href="#sigma_k">sigma_k</a> |
          <a href="#nc_k">nc_k</a>
        </p>
      </li>
    </ul>
    <p><a href="../README.html">back to main page</a></p>
    <h2 id="structureofthefile">Structure of the file</h2>
    <p>
      Below is an example INPUT file with some of the most important parameters
      that need to be set:
    </p>
    <pre><code>INPUT_PARAMETERS
#Parameters (General)
ntype 1
nbands 4
#Parameters (Accuracy)
ecutwfc 60
</code></pre>
    <p>
      Parameters list starts with key word <code>INPUT_PARAMETERS</code>. Any
      content before <code>INPUT_PARAMETERS</code> will be ignored.
    </p>
    <p>
      Any line starting with <code>#</code> or <code>/</code> will also be
      ignored.
    </p>
    <p>
      Each parameter value is provided by specifying the name of the input
      variable and then putting the value after the name, separated by one or
      more blank characters(space or tab). The following characters(â¤ 150) in
      the same line will be neglected.
    </p>
    <p>
      Depending on the input variable, the value may be an integer, a real
      number or a string. The parameters can be given in any order, but only one
      parameter should be given per line.
    </p>
    <p>
      Furthermore, if a given parameter name appeared more than once in the
      input file, only the last value will be taken.
    </p>
    <blockquote>
      <p>
        Note: if a parameter name is not recognized by the program, the program
        will stop with an error message.
      </p>
    </blockquote>
    <p>In the above example, the meanings of the parameters are:</p>
    <ul>
      <li><code>ntype</code> : how many types of elements in the unit cell</li>
      <li><code>nbands</code> : the number of bands to be calculated</li>
      <li>
        <code>ecutwfc</code> : the plane-wave energy cutoff for the wave
        function expansion (UNIT: Rydberg)
      </li>
    </ul>
    <h2 id="listofkeywords">List of keywords</h2>
    <h3 id="systemvariables">System variables</h3>
    <p>This part of variables are used to control general system parameters.</p>
    <h4 id="suffix">suffix</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: In each run, ABACUS will generate a
        subdirectory in the working directory. This subdirectory contains all
        the information of the run. The subdirectory name has the format:
        OUT.suffix, where the <code>suffix</code> is the name you can pick up
        for your convenience.
      </li>
      <li><strong>Default</strong>: ABACUS</li>
    </ul>
    <h4 id="ntype">ntype</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Number of different atom species in this
        calculations. This value must be set. If the number you set is smaller
        than the atom species in the STRU file, ABACUS only read the
        <code>wrong number</code> of atom information. If the number is larger
        than the atom species in the STRU file, ABACUS may stop and quit.
      </li>
      <li><strong>Default</strong>: <strong>_No default value_</strong></li>
    </ul>
    <h4 id="calculation">calculation</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li><strong>Description</strong>: Specify the type of calculation.</li>
      <li>_scf_: do self-consistent electronic structure calculation</li>
      <li>
        _relax_: do structure relaxation calculation, one can ues
        <code>relax_nmax</code> to decide how many ionic relaxations you want.
      </li>
      <li>_cell-relax_: do cell relaxation calculation.</li>
      <li>
        _nscf_: do the non self-consistent electronic structure calculations.
        For this option, you need a charge density file. For nscf calculations
        with planewave basis set, pw_diag_thr should be &lt;= 1d-3.
      </li>
      <li>
        _istate_: Please see the explanation for variable
        <code>nbands_istate</code>.
      </li>
      <li>
        _ienvelope_: Please see the explanation for variable
        <code>nbands_istate</code>.
      </li>
      <li>_md_: molecular dynamics</li>
      <li>
        _sto-scf_: do self-consistent electronic structure calculation with
        <a href="#electronic-structure-sdft">stochastic DFT</a>
      </li>
      <li>
        _sto-md_: molecular dynamics with
        <a href="#electronic-structure-sdft">stochastic DFT</a>
      </li>
      <li>
        _test_memory_ : checks memory required for the calculation. The number
        is not quite reliable, please use with care
      </li>
      <li>_test_neighbour_ : only performs neighbouring atom search</li>
      <li>
        _gen_jle_ : generates projectors for DeePKS; see also
        deepks_lmax_descriptor
      </li>
    </ul>
    <blockquote>
      <p>
        Note: _istate_ and _ienvelope_ only work for LCAO basis set and are not
        working right now.
      </p>
      <ul>
        <li><strong>Default</strong>: scf</li>
      </ul>
    </blockquote>
    <h4 id="symmetry">symmetry</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>: takes value 1, 0 and -1.</li>
      <li>
        if set to 1, symmetry analysis will be performed to determine the type
        of Bravais lattice and associated symmetry operations. (point groups
        only)
      </li>
      <li>
        if set to 0, only time reversal symmetry would be considered in symmetry
        operations, which implied k point and -k point would be treated as one
        double weight k point.
      </li>
      <li>if set to -1, any symmetry will not be considered.</li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="kpar">kpar</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: devide all processors into kpar groups,
        and k points will be distributed among each group. The value taken
        should be less than or equal to the number of k points as well as the
        number of MPI threads.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="bndpar">bndpar</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: devide all processors into bndpar groups,
        and bands (only stochastic orbitals now) will be distributed among each
        group. It should be larger than 0.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="latname">latname</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: Specifies the type of Bravias lattice.
        When set to <code>test</code>, the three lattice vectors are supplied
        explicitly in STRU file. When set to certain Bravais lattice type, there
        is no need to provide lattice vector, but a few lattice parameters might
        be required. For more information regarding this parameter, consult the
        <a href="input-stru.html">page on STRU file</a>. Available options are:
      </li>
      <li><code>test</code>: free strcture.</li>
      <li><code>sc</code>: simple cubie.</li>
      <li><code>fcc</code>: face-centered cubic.</li>
      <li><code>bcc</code>: body-centered cubic.</li>
      <li><code>hexagonal</code>: hexagonal.</li>
      <li><code>trigonal</code>: trigonal.</li>
      <li><code>st</code>: simple tetragonal.</li>
      <li><code>bct</code>: body-centered tetragonal.</li>
      <li><code>so</code>: orthorhombic.</li>
      <li><code>baco</code>: base-centered orthorhombic.</li>
      <li><code>fco</code>: face-centered orthorhombic.</li>
      <li><code>bco</code>: body-centered orthorhombic.</li>
      <li><code>sm</code>: simple monoclinic.</li>
      <li><code>bacm</code>: base-centered monoclinic.</li>
      <li><code>triclinic</code>: triclinic.</li>
      <li><strong>Default</strong>: <code>test</code></li>
    </ul>
    <h4 id="init_wfc">init_wfc</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: Only useful for plane wave basis only now.
        It is the name of the starting wave functions. In the future we should
        also make this variable available for localized orbitals set. Available
        options are:
      </li>
      <li>
        <code>atomic</code>: from atomic pseudo wave functions. If they are not
        enough, other wave functions are initialized with random numbers.
      </li>
      <li>
        <code>atomic+random</code>: add small random numbers on atomic
        pseudo-wavefunctions
      </li>
      <li><code>file</code>: from file</li>
      <li><code>random</code>: random numbers</li>
      <li><strong>Default</strong>:<code>atomic</code></li>
    </ul>
    <h4 id="init_chg">init_chg</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This variable is used for both plane wave
        set and localized orbitals set. It indicates the type of starting
        density. If set this to <code>atomic</code>, the density is starting
        from summation of atomic density of single atoms. If set this to
        <code>file</code>, the density will be read in from file. Besides, when
        you do <code>nspin=1</code> calculation, you only need the density file
        SPIN1_CHGCAR. However, if you do <code>nspin=2</code> calculation, you
        also need the density file SPIN2_CHGCAR. The density file should be
        output with these names if you set out_chg = 1 in INPUT file.
      </li>
      <li><strong>Default</strong>: atomic</li>
    </ul>
    <h4 id="init_vel">init_vel</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: Read the atom velocity from the atom file
        (STRU) if set to true.
      </li>
      <li><strong>Default</strong>: false</li>
    </ul>
    <h4 id="nelec">nelec</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: If &gt;0.0, this denotes total number of
        electrons in the system. Must be less than 2*nbands. If set to 0.0, the
        total number of electrons will be calculated by the sum of valence
        electrons (i.e. assuming neutral system).
      </li>
      <li><strong>Default</strong>: 0.0</li>
    </ul>
    <h4 id="tot_magnetization">tot_magnetization</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li><strong>Description</strong>: Total magnetization of the system.</li>
      <li><strong>Default</strong>: 0.0</li>
    </ul>
    <h4 id="dft_functional">dft_functional</h4>
    <ul>
      <li>
        <p><strong>Type</strong>: String</p>
      </li>
      <li>
        <p>
          <strong>Description</strong>: type of exchange-correlation functional
          used in calculation. If dft_functional is not set, the program will
          adopt the functional used to generate pseudopotential files, provided
          all of them are generated using the same functional. For example, we
          present a few lines in Siâs GGA pseudopotential file
          Si_ONCV_PBE-1.0.upf:
          <code>
            ... &lt;PP_HEADER generated="Generated using ONCVPSP code by D. R.
            Hamann" author="Martin Schlipf and Francois Gygi" date="150105"
            comment="" element="Si" pseudo_type="NC" relativistic="scalar"
            is_ultrasoft="F" is_paw="F" is_coulomb="F" has_so="F" has_wfc="F"
            has_gipaw="F" core_correction="F" functional="PBE" z_valence=" 4.00"
            total_psenergy=" -3.74274958433E+00" rho_cutoff=" 6.01000000000E+00"
          </code>
          According to the information above, this pseudopotential is generated
          using PBE functional. On the other hand, if dft_functional is
          specified, it will overwrite the functional from pseudopotentials and
          performs calculation with whichever functional the user prefers. We
          further offer two ways of supplying exchange-correlation functional.
          The first is using 'short-hand' names such as 'LDA', 'PBE', 'SCAN'. A
          complete list of 'short-hand' expressions can be found in
          <a href="../source/module_xc/xc_functional.cpp">source code</a>. The
          other way is only available when
          <strong>_compiling with LIBXC_</strong>, and it allows for supplying
          exchange-correlation functionals as combinations of LIBXC keywords for
          functional components, joined by plus sign, for example,
          'dft_functional='LDA_X_1D_EXPONENTIAL+LDA_C_1D_CSC'. The list of LIBXC
          keywords can be found on its
          <a href="https://www.tddft.org/programs/libxc/functionals/">website</a
          >. In this way,
          <strong
            >we support all the LDA,GGA and mGGA functionals provided by
            LIBXC</strong
          >.
        </p>
        <p>
          Furthermore, the old INPUT parameter exx_hybrid_type for hybrid
          functionals has been absorbed into dft_functional. Options are
          <code>hf</code> (pure Hartree-Fock), <code>pbe0</code>(PBE0),
          <code>hse</code> (Note: in order to use HSE functional, LIBXC is
          required). Note also that HSE has been tested while PBE0 has NOT been
          fully tested yet, and the maximum parallel cpus for running exx is
          Nx(N+1)/2, with N being the number of atoms. And forces for hybrid
          functionals are not supported yet.
        </p>
        <p>
          If set to <code>opt_orb</code>, the program will not perform hybrid
          functional calculation. Instead, it is going to generate opt-ABFs as
          discussed in this
          <a href="https://pubs.acs.org/doi/abs/10.1021/acs.jpclett.0c00481"
            >article</a
          >.
        </p>
      </li>
      <li>
        <p><strong>Default</strong>: same as UPF file.</p>
      </li>
    </ul>
    <h4 id="pseudo_type">pseudo_type</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: the format of pseudopotential files.
        Accepted value s are:
      </li>
      <li>upf : .UPF format</li>
      <li>vwr : .vwr format</li>
      <li>upf201 : the new UPF format</li>
      <li>blps : bulk local pseudopotential</li>
      <li><strong>Default</strong> : upf</li>
    </ul>
    <h4 id="pseudo_rcut">pseudo_rcut</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Cut-off of radial integration for
        pseudopotentials, in Bohr.
      </li>
      <li><strong>Default</strong>: 15</li>
    </ul>
    <h4 id="pseudo_mesh">pseudo_mesh</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to 0, then use our own mesh for
        radial integration of pseudopotentials; if set to 1, then use the mesh
        that is consistent with quantum espresso.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="mem_saver">mem_saver</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: Used only for nscf calculations. If set to
        1, then a memory saving technique will be used for many k point
        calculations.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="diago_proc">diago_proc</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Descrption</strong>: If set to a positive number, then it
        specifies the number of threads used for carrying out diagonalization.
        Must be less than or equal to total number of MPI threads. Also, when cg
        diagonalization is used, diago_proc must be same as total number of MPI
        threads. If set to 0, then it will be set to the number of MPI threads.
        Normally, it is fine just leaving it to default value. Only used for pw
        base.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="nbspline">nbspline</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Descrption</strong>: If set to a natural number, a Cardinal
        B-spline interpolation will be used to calculate Structure Factor.
        <code>nbspline</code> represents the order of B-spline basis and larger
        one can get more accurate results but cost more. It is turned off by
        default.
      </li>
      <li><strong>Default</strong>: -1</li>
    </ul>
    <h4 id="kspacing">kspacing</h4>
    <ul>
      <li><strong>Type</strong>: double</li>
      <li>
        <strong>Descrption</strong>: Set the smallest allowed spacing between k
        points, unit in 1/bohr. It should be larger than 0.0, and suggest
        smaller than 0.25. When you have set this value &gt; 0.0, then the KPT
        file is unneccessary, and the number of K points nk_i =
        max(1,int(|b_i|/KSPACING)+1), where b_i is the reciprocal lattice
        vector. The default value 0.0 means that ABACUS will read the applied
        KPT file. Notice: if gamma_only is set to be true, kspacing is invalid.
      </li>
      <li><strong>Default</strong>: 0.0</li>
    </ul>
    <h4 id="min_dist_coef">min_dist_coef</h4>
    <ul>
      <li><strong>Type</strong>: double</li>
      <li>
        <strong>Descrption</strong>: a factor related to the allowed minimum
        distance between two atoms. At the begining, ABACUS will check the
        structure, and if the distance of two atoms is shorter than
        min_dist_coef*(standard covalent bond length), we think this structure
        is unreasonable. If you want to calculate some structures in extreme
        condition like high pressure, you should set this parameter as a smaller
        value or even 0.
      </li>
      <li><strong>Default</strong>: 0.2</li>
    </ul>
    <h3 id="variablesrelatedtoinputfiles">Variables related to input files</h3>
    <p>
      This part of variables are used to control input files related parameters.
    </p>
    <h4 id="stru_file">stru_file</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This parameter specifies the name of
        structure file which contains various information about atom species,
        including pseudopotential files, local orbitals files, cell information,
        atom positions, and whether atoms should be allowed to move.
      </li>
      <li><strong>Default</strong>: STRU</li>
    </ul>
    <h4 id="kpoint_file">kpoint_file</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This parameter specifies the name of
        k-points file. Note that if you use atomic orbitals as basis, and you
        only use gamma point, you don't need to have k-point file in your
        directory, ABACUS will automatically generate <code>KPT</code> file.
        Otherwise, if you use more than one k-point, please do remember the
        algorithm in ABACUS is different for gamma only and various k-point
        dependent simulations. So first you should turn off the k-point
        algorithm by set <code>gamma_only = 0</code> in <code>INPUT</code> and
        then you should setup your own k-points file.
      </li>
      <li><strong>Default</strong>: KPT</li>
    </ul>
    <h4 id="pseudo_dir">pseudo_dir</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This parameter specifies pseudopotential
        directory.
      </li>
      <li><strong>Default</strong>: ./</li>
    </ul>
    <h4 id="orbital_dir">orbital_dir</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This parameter specifies orbital file
        directory.
      </li>
      <li><strong>Default</strong>: ./</li>
    </ul>
    <h4 id="read_file_dir">read_file_dir</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: when the program needs to read files such
        as electron density(<code>SPIN1_CHG</code>) as a starting point, this
        variables tells the location of the files. For example, './' means the
        file is located in the working directory.
      </li>
      <li><strong>Default</strong>: OUT.$suffix</li>
    </ul>
    <h3 id="planewaverelatedvariables">Plane wave related variables</h3>
    <p>
      This part of variables are used to control the plane wave related
      parameters.
    </p>
    <h4 id="ecutwfc">ecutwfc</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Energy cutoff for plane wave functions,
        the unit is <strong>Rydberg</strong>. Note that even for localized
        orbitals basis, you still need to setup a energy cutoff for this system.
        Because our local pseudopotential parts and the related force are
        calculated from plane wave basis set, etc. Also, because our orbitals
        are generated by matching localized orbitals to a chosen set of wave
        functions from certain energy cutoff, so this set of localize orbitals
        are most accurate under this same plane wave energy cutoff.
      </li>
      <li><strong>Default</strong>: 50</li>
    </ul>
    <h4 id="nxnynz">nx, ny, nz</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to a positive number, then the
        three variables specify the numbers of FFT grid points in x, y, z
        directions, respectively. If set to 0, the number will be calculated
        from ecutwfc.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="pw_seed">pw_seed</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Only useful for plane wave basis only now.
        It is the random seed to initialize wave functions. Only positive
        integers are avilable.
      </li>
      <li><strong>Default</strong>:0</li>
    </ul>
    <h4 id="pw_diag_thr">pw_diag_thr</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Only used when you use
        <code>diago_type = cg</code> or <code>diago_type = david</code>. It
        indicates the threshold for the first electronic iteration, from the
        second iteration the pw_diag_thr will be updated automatically.
        <strong
          >For nscf calculations with planewave basis set, pw_diag_thr should be
          &lt;= 1d-3.</strong
        >
      </li>
      <li><strong>Default</strong>: 0.01</li>
    </ul>
    <h4 id="pw_diag_nmax">pw_diag_nmax</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Only useful when you use
        <code>ks_solver = cg</code> or <code>ks_solver = dav</code>. It
        indicates the maximal iteration number for cg/david method.
      </li>
      <li><strong>Default</strong>: 40</li>
    </ul>
    <h4 id="pw_diag_ndim">pw_diag_ndim</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Only useful when you use
        <code>ks_solver = dav</code>. It indicates the maximal dimension for the
        Davidson method.
      </li>
      <li><strong>Default</strong>: 10</li>
    </ul>
    <h3 id="numericalatomicorbitalsrelatedvariables">
      Numerical atomic orbitals related variables
    </h3>
    <p>
      This part of variables are used to control the numerical atomic orbitals
      related parameters.
    </p>
    <h4 id="nb2d">nb2d</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: In LCAO calculations, we arrange the total
        number of processors in an 2D array, so that we can partition the
        wavefunction matrix (number of bands*total size of atomic orbital basis)
        and distribute them in this 2D array. When the system is large, we group
        processors into sizes of nb2d, so that multiple processors take care of
        one row block (a group of atomic orbitals) in the wavefunction matrix.
        If set to 0, nb2d will be automatically set in the program according to
        the size of atomic orbital basis:
      </li>
      <li>if size &lt;= 500 : nb2d = 1</li>
      <li>if 500 &lt; size &lt;= 1000 : nb2d = 32</li>
      <li>if size &gt; 1000 : nb2d = 64;</li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="lmaxmax">lmaxmax</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If not equals to 2, then the maximum l
        channels on LCAO is set to lmaxmax. If 2, then the number of l channels
        will be read from the LCAO data sets. Normally no input should be
        supplied for this variable so that it is kept as its default.
      </li>
      <li><strong>Default</strong>: 2.</li>
    </ul>
    <h4 id="lcao_ecut">lcao_ecut</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Energy cutoff when calculating LCAO
        two-center integrals. In Ry.
      </li>
      <li><strong>Default</strong>: 50</li>
    </ul>
    <h4 id="lcao_dk">lcao_dk</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li><strong>Description</strong>: Delta k for 1D integration in LCAO</li>
      <li><strong>Default</strong>: 0.01</li>
    </ul>
    <h4 id="lcao_dr">lcao_dr</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li><strong>Description</strong>: Delta r for 1D integration in LCAO</li>
      <li><strong>Default</strong>: 0.01</li>
    </ul>
    <h4 id="lcao_rmax">lcao_rmax</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Max R for 1D two-center integration table
      </li>
      <li><strong>Default</strong>: 30</li>
    </ul>
    <h4 id="search_radius">search_radius</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Set the search radius for finding
        neighbouring atoms. If set to -1, then the radius will be set to maximum
        of projector and orbital cut-off.
      </li>
      <li><strong>Default</strong>: -1</li>
    </ul>
    <h4 id="search_pbc">search_pbc</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: In searching for neighbouring atoms, if
        set to 1, then periodic images will also be searched. If set to 0, then
        periodic images will not be searched.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h3 id="electronicstructure">Electronic structure</h3>
    <p>
      This part of variables are used to control the electronic structure and
      geometry relaxation calculations.
    </p>
    <h4 id="basis_type">basis_type</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This is very important parameters to
        choose basis set in ABACUS.
      </li>
      <li>_pw_: Using plane-wave basis set only.</li>
      <li>
        _lcao_in_pw_: Expand the localized atomic set in plane-wave basis.
      </li>
      <li>lcao: Using localized atomic orbital sets.</li>
      <li><strong>Default</strong>: pw</li>
    </ul>
    <h4 id="ks_solver">ks_solver</h4>
    <ul>
      <li>
        <p><strong>Type</strong>: String</p>
      </li>
      <li>
        <p>
          <strong>Description</strong>: It`s about choice of diagonalization
          methods for hamiltonian matrix expanded in a certain basis set.
        </p>
        <p>For plane-wave basis,</p>
      </li>
      <li><p>cg: cg method.</p></li>
      <li>
        <p>
          dav: the Davidson algorithm. (Currently not working with Intel MKL
          library).
        </p>
        <p>For atomic orbitals basis,</p>
      </li>
      <li>
        <p>
          genelpa: This method should be used if you choose localized orbitals.
        </p>
      </li>
      <li><p>hpseps: old method, still used.</p></li>
      <li>
        <p>
          lapack: lapack can be used for localized orbitals, but is only used
          for single processor.
        </p>
      </li>
      <li>
        <p>
          cusolver: this method needs building with the cusolver component for
          lcao and at least one gpu is available.
        </p>
        <p>
          If you set ks_solver=<code>hpseps</code> for
          basis_type=<code>pw</code>, the program will be stopped with an error
          message:
        </p>
        <pre><code class="txt language-txt">hpseps can not be used with plane wave basis.
</code></pre>
        <p>
          Then the user has to correct the input file and restart the
          calculation.
        </p>
      </li>
      <li>
        <p>
          <strong>Default</strong>: <code>cg</code> (pw) or
          <code>genelpa</code> (lcao)
        </p>
      </li>
    </ul>
    <h4 id="nbands">nbands</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Number of Kohn-Sham orbitals to calculate.
        It is recommended you setup this value, especially when you use smearing
        techniques, more bands should be included.
      </li>
      <li><strong>Default</strong>:</li>
      <li>nspin=1: 1.2*occupied_bands, occupied_bands+10)</li>
      <li>nspin=2: max(1.2*nelec, nelec+20)</li>
    </ul>
    <h4 id="nbands_istate">nbands_istate</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Only used when
        <code>calculation = ienvelope</code> or
        <code>calculation = istate</code>, this variable indicates how many
        bands around Fermi level you would like to calculate.
        <code>ienvelope</code> means to calculate the envelope functions of wave
        functions $\Psi_{i}=\Sigma_{\mu}C_{i\mu}\Phi_{\mu}$, where $\Psi_{i}$ is
        the ith wave function with the band index $i$ and $\Phi_{\mu}$ is the
        localized atomic orbital set. <code>istate</code> means to calculate the
        density of each wave function $|\Psi_{i}|^{2}$. Specifically, suppose we
        have highest occupied bands at 100th wave functions. And if you set this
        variable to 5, it will print five wave functions from 96th to 105th. But
        before all this can be carried out, the wave functions coefficients
        should be first calculated and written into a file by setting the flag
        <code>out_wfc_lcao = 1</code>.
      </li>
      <li><strong>Default</strong>: 5</li>
    </ul>
    <h4 id="nspin">nspin</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Number of spin components of wave
        functions. There are only two choices now: 1 or 2, meaning non spin or
        collinear spin.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="occupations">occupations</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: Specifies how to calculate the occupations
        of bands. Available options are:
      </li>
      <li>
        'smearing' : gaussian smearing for metals; see also variables
        <code>smearing_method</code> and <code>smearing_sigma</code>.
      </li>
      <li>
        'tetrahedra' : Tetrahedron method, Bloechl's version:
        <a
          href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.49.16223"
          >P.E. Bloechl, PRB 49, 16223 (1994)</a
        >. Requires a uniform grid of k-points that are automatically generated.
        Well suited for calculation of DOS, less so (because not variational)
        for force/optimization/dynamics calculations.
      </li>
      <li>'fixed' : for insulators with a gap</li>
      <li><strong>Default</strong>: 'smearing'</li>
    </ul>
    <h4 id="smearing_method">smearing_method</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: It indicates which occupation and smearing
        method is used in the calculation.
      </li>
      <li>fixed: use fixed occupations.</li>
      <li>gauss or gaussian: use gaussian smearing method.</li>
      <li>
        mp: use methfessel-paxton smearing method. The method recommends for
        metals.
      </li>
      <li><strong>Default</strong>: fixed</li>
    </ul>
    <h4 id="smearing_sigma">smearing_sigma</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: energy range for smearing, the unit is
        Rydberg.
      </li>
      <li><strong>Default</strong>: 0.001</li>
    </ul>
    <h4 id="mixing_type">mixing_type</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li><strong>Description</strong>: Charge mixing methods.</li>
      <li>plain: Just simple mixing.</li>
      <li>kerker: Use kerker method, which is the mixing method in G space.</li>
      <li>pulay: Standard Pulay method.</li>
      <li>pulay-kerker:</li>
      <li><strong>Default</strong>: pulay</li>
    </ul>
    <h4 id="mixing_beta">mixing_beta</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: mixing parameter: 0 means no new charge
      </li>
      <li><strong>Default</strong>: 0.7</li>
    </ul>
    <h4 id="mixing_ndim">mixing_ndim</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: It indicates the mixing dimensions in
        Pulay, Pulay method use the density from previous mixing_ndim steps and
        do a charge mixing based on these density.
      </li>
      <li><strong>Default</strong>: 8</li>
    </ul>
    <h4 id="mixing_gg0">mixing_gg0</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li><strong>Description</strong>: used in pulay-kerker mixing method</li>
      <li><strong>Default</strong>: 1.5</li>
    </ul>
    <h4 id="gamma_only">gamma_only</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: It is an important parameter
        <strong>only to be used in localized orbitals set</strong>. It you set
        gamma_only = 1, ABACUS use gamma only, the algorithm is fast and you
        don't need to specify the k-points file. If you set gamma_only = 0, more
        than one k-point is used and the ABACUS is slower compared to gamma only
        algorithm.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="printe">printe</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Print out energy for each band for every
        printe steps
      </li>
      <li><strong>Default</strong>: 100</li>
    </ul>
    <h4 id="scf_nmax">scf_nmax</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>:This variable indicates the maximal
        iteration number for electronic iterations.
      </li>
      <li><strong>Default</strong>: 40</li>
    </ul>
    <h4 id="scf_thr">scf_thr</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: An important parameter in ABACUS. It`s the
        threshold for electronic iteration. It represents the charge density
        error between two sequential density from electronic iterations. Usually
        for local orbitals, usually 1e-6 may be accurate enough.
      </li>
      <li><strong>Default</strong>:1e-06</li>
    </ul>
    <h4 id="chg_extrap">chg_extrap</h4>
    <ul>
      <li>
        <p><strong>Type</strong>: String</p>
      </li>
      <li>
        <p>
          <strong>Description</strong>: Methods to do extrapolation of density
          when ABACUS is doing geometry relaxations.
        </p>
      </li>
      <li><p>atomic: atomic extrapolation</p></li>
      <li><p>first-order: first-order extrapolation</p></li>
      <li><p>second-order: second-order extrapolation</p></li>
      <li>
        <p><strong>Default</strong>:atomic</p>
        <p>by time(NULL).</p>
      </li>
      <li>
        <p><strong>Default</strong>:0</p>
      </li>
    </ul>
    <h3 id="electronicstructuresdft">Electronic structure (SDFT)</h3>
    <p>
      This part of variables are used to control the parameters of stochastic
      DFT (SDFT), mix stochastic-deterministic DFT (MDFT), or complete-basis
      Chebyshev method (CT). To use it,
      <a href="#calculation">calculation</a> need to be set to "sto-scf" and
      "sto-md". We suggest using SDFT to calculate high-temperature systems and
      we only support <a href="#smearing_method">smearing_method</a> "fd".
    </p>
    <h4 id="method_sto">method_sto</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>Different method to do SDFT.</li>
      <li>
        1: SDFT calculates $T_n(\hat{h})\ket{\chi}$ twice, where $T_n(x)$ is the
        n-th order Chebyshev polynomial and
        $\hat{h}=\frac{\hat{H}-\bar{E}}{\Delta E}$ owning eigen-value
        $\in(-1,1)$. This method cost less memory but slow.
      </li>
      <li>
        2: SDFT calculates $T_n(\hat{h})\ket{\chi}$ once but need much more
        memory. This method is much faster. Besides, it calculate $N_e$ with
        $\bra{\chi}\sqrt{\hat f}\sqrt{\hat f}\ket{\chi}$, which needs smaller
        <a href="#nche_sto">nche_sto</a>. However, when memory is not enough,
        only method 1 can be used.
      </li>
      <li>other: use 2</li>
      <li><strong>Default</strong>: 2</li>
    </ul>
    <h4 id="nbands_sto">nbands_sto</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>
        nbands_sto&gt;0: Number of stochastic orbitals to calculate in SDFT and
        MDFT. More bands obtain more precise results or smaller stochastic
        errors ($ \propto 1/\sqrt{N_{\chi}}$);
      </li>
      <li>
        nbands_sto=0: Complete basis will be used to replace stochastic orbitals
        with the Chebyshev method (CT) and it will get the results the same as
        KSDFT without stochastic errors.
      </li>
      <li>
        If you want to do MDFT. <a href="#nbands">nbands</a> which represents
        the number of KS orbitals should be set.
      </li>
      <li><strong>Default</strong>: 256</li>
    </ul>
    <h4 id="nche_sto">nche_sto</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Chebyshev expansion orders for SDFT, MDFT,
        CT methods.
      </li>
      <li><strong>Default</strong>:100</li>
    </ul>
    <h4 id="emin_sto">emin_sto</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Trial energy to guess the lower bound of
        eigen energies of the Hamitonian Operator $\hat{H}$. The unit is Ry.
      </li>
      <li><strong>Default</strong>:0.0</li>
    </ul>
    <h4 id="emax_sto">emax_sto</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Trial energy to guess the upper bound of
        eigen energies of the Hamitonian Operator $\hat{H}$. The unit is Ry.
      </li>
      <li><strong>Default</strong>:0.0</li>
    </ul>
    <h4 id="seed_sto">seed_sto</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: The random seed to generate stochastic
        orbitals.
      </li>
      <li>
        seed_sto&gt;=0: Stochastic orbitals have the form of
        $\exp(i2\pi\theta(G))$, where $\theta$ is a uniform distribution in
        $(0,1)$. If seed_sto = 0, the seed is decided by time(NULL).
      </li>
      <li>
        seed_sto&lt;=-1: Stochastic orbitals have the form of $\pm1$ with the
        equal probability. If seed_sto = -1, the seed is decided by time(NULL).
      </li>
      <li><strong>Default</strong>:0</li>
    </ul>
    <h4 id="initsto_freq">initsto_freq</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Frequency (once each initsto_freq steps)
        to generate new stochastic orbitals when running md.
      </li>
      <li><strong>Default</strong>:1000</li>
    </ul>
    <h4 id="npart_sto">npart_sto</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Make memory cost to 1/npart_sto times of
        previous one when running post process of SDFT like DOS with method_sto
        = 2.
      </li>
      <li><strong>Default</strong>:1</li>
    </ul>
    <h3 id="geometryrelaxation">Geometry relaxation</h3>
    <p>This part of variables are used to control the geometry relaxation.</p>
    <h4 id="relax_nmax">relax_nmax</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: The maximal number of ionic iteration
        steps, the minimal value is 1.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="cal_force">cal_force</h4>
    <ul>
      <li>
        <strong>Description</strong>: If set to 1, calculate the force at the
        end of the electronic iteration. 0 means the force calculation is turned
        off.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="force_thr">force_thr</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The threshold of the force convergence, it
        indicates the largest force among all the atoms, the unit is Ry=Bohr
      </li>
      <li><strong>Default</strong>: 0.000388935 Ry/Bohr = 0.01 eV/Angstrom</li>
    </ul>
    <h4 id="force_thr_ev">force_thr_ev</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The threshold of the force convergence,
        has the same function as force_thr, just the unit is different, it is
        eV=Angstrom, you can choose either one as you like. The recommendation
        value for using atomic orbitals is 0:04 eV/Angstrom.
      </li>
      <li><strong>Default</strong>: 0.01 eV/Angstrom</li>
    </ul>
    <h4 id="relax_bfgs_w1">relax_bfgs_w1</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This variable controls the Wolfe condition
        for BFGS algorithm used in geometry relaxation. You can look into paper
        Phys.Chem.Chem.Phys.,2000,2,2177 for more information.
      </li>
      <li><strong>Default</strong>: 0.01</li>
    </ul>
    <h4 id="relax_bfgs_w2">relax_bfgs_w2</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This variable controls the Wolfe condition
        for BFGS algorithm used in geometry relaxation. You can look into paper
        Phys.Chem.Chem.Phys.,2000,2,2177 for more information.
      </li>
      <li><strong>Default</strong>: 0.5</li>
    </ul>
    <h4 id="relax_bfgs_rmax">relax_bfgs_rmax</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This variable is for geometry
        optimization. It indicates the maximal movement of all the atoms. The
        sum of the movements from all atoms can be increased during the
        optimization steps. However, it will not be larger than relax_bfgs_rmax
        Bohr.
      </li>
      <li><strong>Default</strong>: 0.8</li>
    </ul>
    <h4 id="relax_bfgs_rmin">relax_bfgs_rmin</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This variable is for geometry
        optimization. It indicates the minimal movement of all the atoms. When
        the movement of all the atoms is smaller than relax_bfgs_rmin Bohr , and
        the force convergence is still not achieved, the calculation will break
        down.
      </li>
      <li><strong>Default</strong>: 1e-5</li>
    </ul>
    <h4 id="relax_bfgs_init">relax_bfgs_init</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This variable is for geometry
        optimization. It indicates the initial movement of all the atoms. The
        sum of the movements from all atoms is relax_bfgs_init Bohr.
      </li>
      <li><strong>Default</strong>: 0.5</li>
    </ul>
    <h4 id="cal_stress">cal_stress</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to 1, calculate the stress at the
        end of the electronic iteration. 0 means the stress calculation is
        turned off.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="stress_thr">stress_thr</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The threshold of the stress convergence,
        it indicates the largest stress among all the directions, the unit is
        KBar,
      </li>
      <li><strong>Default</strong>: 0.01</li>
    </ul>
    <h4 id="press1press2press3">press1, press2, press3</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: the external pressures along three
        axes,the compressive stress is taken to be positive, the unit is KBar.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="fixed_axes">fixed_axes</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>:which axes are fixed when do cell
        relaxation. Possible choices are:
      </li>
      <li>None : default; all can relax</li>
      <li>volume : relaxation with fixed volume</li>
      <li>a : fix a axis during relaxation</li>
      <li>b : fix b axis during relaxation</li>
      <li>c : fix c axis during relaxation</li>
      <li>ab : fix both a and b axes during relaxation</li>
      <li>ac : fix both a and c axes during relaxation</li>
      <li>bc : fix both b and c axes during relaxation</li>
      <li>abc : fix all three axes during relaxation</li>
      <li><strong>Default</strong>: None</li>
    </ul>
    <h4 id="relax_method">relax_method</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: The method to do geometry optimizations.
        If set to bfgs, using BFGS algorithm. If set to cg, using cg algorithm.
        If set to sd, using steepest-descent lgorithm.
      </li>
      <li><strong>Default</strong>: cg</li>
    </ul>
    <h4 id="relax_cg_thr">relax_cg_thr</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: When move-method is set to 'cg-bfgs', a
        mixed cg-bfgs algorithm is used. The ions first move according to cg
        method, then switched to bfgs when maximum of force on atoms is reduced
        below cg-threshold. Unit is eV/Angstrom.
      </li>
      <li><strong>Default</strong>: 0.5</li>
    </ul>
    <h4 id="cell_factor">cell_factor</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Used in the construction of the
        pseudopotential tables. It should exceed the maximum linear contraction
        of the cell during a simulation.
      </li>
      <li><strong>Default</strong>: 1.2</li>
    </ul>
    <h3 id="variablesrelatedtooutputinformation">
      Variables related to output information
    </h3>
    <p>This part of variables are used to control the output of properties.</p>
    <h4 id="out_force">out_force</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Determines whether to output the out_force
        into a file named <code>Force.dat</code> or not. If 1, then force will
        be written; if 0, then the force will not be written.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_mul">out_mul</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to 1, ABACUS will output the
        Mulliken population analysis result. The name of the output file is
        mulliken.txt
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_freq_elec">out_freq_elec</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to &gt;1, it represents the
        frequency of electronic iters to output charge density (if
        <a href="#out_chg">out_chg</a> is turned on) and wavefunction (if
        <a href="#out_wf_pw">out_wfc_pw</a> or
        <a href="#out_wfc_r">out_wfc_r</a> is turned on). If set to 0, ABACUS
        will output them only when converged in SCF. Used for the restart of
        SCF.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_freq_ion">out_freq_ion</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to &gt;1, it represents the
        frequency of ionic steps to output charge density (if
        <a href="#out_chg">out_chg</a> is turned on) and wavefunction (if
        <a href="#out_wf_pw">out_wfc_pw</a> or
        <a href="#out_wfc_r">out_wfc_r</a> is turned on). If set to 0, ABACUS
        will output them only when ionic steps reach its maximum step. Used for
        the restart of MD or Relax.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_chg">out_chg</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to 1, ABACUS will output the charge
        density on real space grid. The name of the density file is SPIN1_CHGCAR
        and SPIN2_CHGCAR (if nspin = 2). Suppose each density on grid has
        coordinate (x; y; z). The circle order of the density on real space grid
        is: z is the outer loop, then y and finally x (x is moving fastest).
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_pot">out_pot</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to 1, ABACUS will output the local
        potential on real space grid. The name of the file is SPIN1_POT and
        SPIN2_POT (if nspin = 2). If set to 2, ABACUS will output the
        electrostatic potential on real space grid. The name of the file is
        ElecStaticPot and ElecStaticP ot_AV E (along the z-axis).
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_dm">out_dm</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: If set to 1, ABACUS will output the
        density matrix of localized orbitals, only useful for localized orbitals
        set. The name of the output file is SPIN1_DM and SPIN2_DM in the output
        directory.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_wfc_pw">out_wfc_pw</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Only used in
        <strong>planewave basis</strong> and
        <strong>ienvelope calculation in localized orbitals</strong> set. When
        set this variable to 1, it outputs the coefficients of wave functions
        into text files. The file names are WAVEFUNC$K.txt, where $K is the
        index of k point. When set this variable to 2, results are stored in
        binary files. The file names are WAVEFUNC$K.dat.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_wfc_r">out_wfc_r</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Only used in
        <strong>planewave basis</strong> and
        <strong>ienvelope calculation in localized orbitals</strong> set. When
        set this variable to 1, it outputs real-space wave functions into
        <code>OUT.suffix/wfc_realspace/</code>. The file names are
        wfc_realspace$K$B, where $K is the index of k point, $B is the index of
        band.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_wfc_lcao">out_wfc_lcao</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>:
        <strong>Only used in localized orbitals set</strong>. If set to 1,
        ABACUS will output the wave functions coefficients.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_dos">out_dos</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Controls whether to output the density of
        state (DOS). For more information, refer to the
        <a href="examples/dos.html">worked example</a>.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_band">out_band</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Controls whether to output the band
        structure. For mroe information, refer to the
        <a href="examples/band-struc.html">worked example</a>
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_proj_band">out_proj_band</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Controls whether to output the projected
        band structure. For mroe information, refer to the
        <a href="examples/band-struc.html">worked example</a>
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_stru">out_stru</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 1, then tje structure files will
        be written after each ion step
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_level">out_level</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: Controls the level of output.
        <code>ie</code> means write output at electron level;
        <code>i</code> means write additional output at ions level.
      </li>
      <li><strong>Default</strong>: ie</li>
    </ul>
    <h4 id="out_alllog">out_alllog</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: determines whether to write log from all
        ranks in an MPI run. If set to be 1, then each rank will write detained
        running information to a file named
        running_${calculation}_(${rank}+1).log. If set to 0, log will only be
        written from rank 0 into a file named running_${calculation}.log.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_mat_hs">out_mat_hs</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: Only for LCAO calculations. When set to 1,
        ABACUS will generate two lists of files <code>data-$k-H</code> and
        <code>data-$k-S</code> that store the Hamiltonian and S matrix for each
        k point in k space, respectively.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_mat_r">out_mat_r</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: Only for LCAO and not gamma_only
        calculations. When set to 1, ABACUS will generate a file with name
        staring with <code>data-rR-tr</code> which stores overlap matrix as a
        function of R, in units of lattice vectors.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_mat_hs2">out_mat_hs2</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: Only for LCAO and not gamma_only
        calculations. When set to 1, ABACUS will generate two files starting
        with <code>data-HR-sparse</code> and <code>data-SR-sparse</code> that
        store the Hamiltonian and S matrix in real space, respectively, as
        functions of R, in units of lattice vectors.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="out_element_info">out_element_info</h4>
    <ul>
      <li>
        <p><strong>Type</strong>: Boolean</p>
      </li>
      <li>
        <p>
          <strong>Description</strong>: When set to 1, ABACUS will generate a
          new directory under OUT.suffix path named as element name such as
          'Si', which contained files "Si-d1-orbital-dru.dat Si-p2-orbital-k.dat
          Si-s2-orbital-dru.dat Si-d1-orbital-k.dat Si-p2-orbital-r.dat
          Si-s2-orbital-k.dat Si-d1-orbital-r.dat Si-p2-orbital-ru.dat
          Si-s2-orbital-r.dat Si-d1-orbital-ru.dat Si-p-proj-k.dat
          Si-s2-orbital-ru.dat Si.NONLOCAL Si-p-proj-r.dat Si-s-proj-k.dat
          Si-p1-orbital-dru.dat Si-p-proj-ru.dat Si-s-proj-r.dat
          Si-p1-orbital-k.dat Si-s1-orbital-dru.dat Si-s-proj-ru.dat
          Si-p1-orbital-r.dat Si-s1-orbital-k.dat v_loc_g.dat
          Si-p1-orbital-ru.dat Si-s1-orbital-r.dat Si-p2-orbital-dru.dat
          Si-s1-orbital-ru.dat" for example.
        </p>
      </li>
      <li>
        <p><strong>Default</strong>: 0</p>
      </li>
    </ul>
    <h4 id="restart_save">restart_save</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: Only for LCAO, store charge density file
        and H matrix file every scf step for restart.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="restart_load">restart_load</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: Only for LCAO, used for restart, only if
        that:
      </li>
      <li>set restart_save as true and do scf calculation before.</li>
      <li>
        please ensure suffix is same with calculation before and density file
        and H matrix file is exist. restart from stored density file and H
        matrix file.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h3 id="densityofstates">Density of states</h3>
    <p>This part of variables are used to control the calculation of DOS.</p>
    <h4 id="dos_edelta_ev">dos_edelta_ev</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: controls the step size in writing DOS (in
        eV).
      </li>
      <li><strong>Default</strong>: 0.1</li>
    </ul>
    <h4 id="dos_sigma">dos_sigma</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: controls the width of Gaussian factor when
        obtaining smeared DOS (in eV).
      </li>
      <li><strong>Default</strong>: 0.07</li>
    </ul>
    <h4 id="dos_scale">dos_scale</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: the energy range of dos output is given by
        (emax-emin)*(1+dos_scale), centered at (emax+emin)/2. This parameter
        will be used when dos_emin and dos_emax are not set.
      </li>
      <li><strong>Default</strong>: 0.01</li>
    </ul>
    <h4 id="dos_emin_ev">dos_emin_ev</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: minimal range for dos (in eV). If we set
        it, "dos_scale" will be ignored.
      </li>
      <li><strong>Default</strong>: minimal eigenenergy of $\hat{H}$</li>
    </ul>
    <h4 id="dos_emax_ev">dos_emax_ev</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: maximal range for dos (in eV). If we set
        it, "dos_scale" will be ignored.
      </li>
      <li><strong>Default</strong>: maximal eigenenergy of $\hat{H}$</li>
    </ul>
    <h4 id="dos_nche">dos_nche</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: orders of Chebyshev expansions when using
        SDFT to calculate DOS
      </li>
      <li><strong>Default</strong>: 100</li>
    </ul>
    <h3 id="deepks">DeePKS</h3>
    <p>
      This part of variables are used to control the usage of DeePKS method (a
      comprehensive data-driven approach to improve accuracy of DFT). Warning:
      this function is not robust enough for the current version. Please try the
      following variables at your own risk:
    </p>
    <h4 id="deepks_out_labels">deepks_out_labels</h4>
    <ul>
      <li>
        <p><strong>Type</strong>: Boolean</p>
      </li>
      <li>
        <p>
          <strong>Description</strong>: when set to 1, ABACUS will calculate and
          output descriptor for DeePKS training. In
          <code>LCAO</code> calculation, a path of *.orb file is needed to be
          specified under <code>NUMERICAL_DESCRIPTOR</code>in
          <code>STRU</code>file. For example:
        </p>
        <pre><code class="txt language-txt">NUMERICAL_ORBITAL
H_gga_8au_60Ry_2s1p.orb
O_gga_7au_60Ry_2s2p1d.orb

NUMERICAL_DESCRIPTOR
jle.orb
</code></pre>
      </li>
      <li>
        <p><strong>Default</strong>: 0</p>
      </li>
    </ul>
    <h4 id="deepks_descriptor_lmax">deepks_descriptor_lmax</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: when generating projectors, this variable
        controls the max angular momentum of descriptor basis.
      </li>
      <li><strong>Default</strong>: 2</li>
    </ul>
    <h4 id="deepks_scf">deepks_scf</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: only when deepks is enabled in
        <code>LCAO</code> calculation can this variable set to 1. Then, a
        trained, traced model file is needed for self-consistant field iteration
        in DeePKS method.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="deepks_model">deepks_model</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: the path of the trained, traced NN model
        file (generated by deepks-kit). used when deepks_scf is set to 1.
      </li>
      <li><strong>Default</strong>: None</li>
    </ul>
    <h3 id="electricfieldanddipolecorrection">
      Electric field and dipole correction
    </h3>
    <p>
      This part of variables are relevant to electric field and dipole
      correction
    </p>
    <h4 id="efield_flag">efield_flag</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to true, a saw-like potential
        simulating an electric field is added to the bare ionic potential.
      </li>
      <li><strong>Default</strong>: false</li>
    </ul>
    <h4 id="dip_cor_flag">dip_cor_flag</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If dip_cor_flag == true and efield_flag ==
        true, a dipole correction is also added to the bare ionic potential. If
        you want no electric field, parameter efield_amp should be zero. Must be
        used ONLY in a slab geometry for surface calculations, with the
        discontinuity FALLING IN THE EMPTY SPACE.
      </li>
      <li><strong>Default</strong>: false</li>
    </ul>
    <h4 id="efield_dir">efield_dir</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: The direction of the electric field or
        dipole correction is parallel to the reciprocal lattice vector, so the
        potential is constant in planes defined by FFT grid points, efield_dir =
        0, 1 or 2. Used only if efield_flag == true.
      </li>
      <li><strong>Default</strong>: 2</li>
    </ul>
    <h4 id="efield_pos_max">efield_pos_max</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Position of the maximum of the saw-like
        potential along crystal axis efield_dir, within the unit cell, 0 &lt;
        efield_pos_max &lt; 1. Used only if efield_flag == true.
      </li>
      <li><strong>Default</strong>: 0.5</li>
    </ul>
    <h4 id="efield_pos_dec">efield_pos_dec</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Zone in the unit cell where the saw-like
        potential decreases, 0 &lt; efield_pos_dec &lt; 1. Used only if
        efield_flag == true.
      </li>
      <li><strong>Default</strong>: 0.1</li>
    </ul>
    <h4 id="efield_amp">efield_amp</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Amplitude of the electric field, in
        <strong>_Hartree_</strong> a.u.; 1 a.u. = 51.4220632*10^10 V/m. Used
        only if efield_flag == true. The saw-like potential increases with slope
        efield_amp in the region from (efield_pos_max+efield_pos_dec-1) to
        (efield_pos_max), then decreases until (efield_pos_max+efield_pos_dec),
        in units of the crystal vector efield_dir. Important: the change of
        slope of this potential must be located in the empty region, or else
        unphysical forces will result.
      </li>
      <li><strong>Default</strong>: 0.0</li>
    </ul>
    <h3 id="exactexchange">Exact Exchange</h3>
    <p>This part of variables are relevant when using hybrid functionals</p>
    <h4 id="exx_hybrid_alpha">exx_hybrid_alpha</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: fraction of Fock exchange in hybrid
        functionals, so that $E_{X}=\alpha F_{X}+(1-\alpha)E_{X,LDA/GGA}$
      </li>
      <li><strong>Default</strong>: 0.25</li>
    </ul>
    <h4 id="exx_hse_omega">exx_hse_omega</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: range-separation parameter in HSE
        functional, such that $1/r=erfc(\omega r)/r+erf(\omega r)/r$.
      </li>
      <li><strong>Default</strong>: 0.11</li>
    </ul>
    <h4 id="exx_separate_loop">exx_separate_loop</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: There are two types of iterative approach
        provided by ABACUS to evaluate Fock exchange. If this parameter is set
        to 0, it will start with a GGA-Loop, and then Hybrid-Loop, in which EXX
        Hamiltonian $H_{exx}$ is updated with electronic iterations. If this
        parameter is set to 1, a two-step method is employed, i.e. in the inner
        iterations, density matrix is updated, while in the outer iterations,
        $H_{exx}$ is calculated based on density matrix that converges in the
        inner iteration.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="exx_hybrid_step">exx_hybrid_step</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: This variable indicates the maximal
        electronic iteration number in the evaluation of Fock exchange.
      </li>
      <li><strong>Default</strong>: 100</li>
    </ul>
    <h4 id="exx_lambda">exx_lambda</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: It is used to compensate for divergence
        points at G=0 in the evaluation of Fock exchange using _lcao_in_pw_
        method.
      </li>
      <li><strong>Default</strong>: 0.3</li>
    </ul>
    <h4 id="exx_pca_threshold">exx_pca_threshold</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: To accelerate the evaluation of
        four-center integrals ($ik|jl$), the product of atomic orbitals are
        expanded in the basis of auxiliary basis functions (ABF):
        $\Phi_{i}\Phi_{j}\sim C^{k}_{ij}P_{k}$. The size of the ABF (i.e. number
        of $P_{k}$) is reduced using principal component analysis. When a large
        PCA threshold is used, the number of ABF will be reduced, hence the
        calculations becomes faster. However this comes at the cost of
        computational accuracy. A relatively safe choice of the value is 1d-4.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="exx_c_threshold">exx_c_threshold</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: See also the entry
        <a href="#exx_pca_threshold">exx_pca_threshold</a>. Smaller components
        (less than exx_c_threshold) of the $C^{k}_{ij}$ matrix is neglected to
        accelerate calculation. The larger the threshold is, the faster the
        calculation and the lower the accuracy. A relatively safe choice of the
        value is 1d-4.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="exx_v_threshold">exx_v_threshold</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: See also the entry
        <a href="#exx_pca_threshold">exx_pca_threshold</a>. With the
        approximation $\Phi_{i}\Phi_{j}\sim C^{k}_{ij}P_{k}$, the four-center
        integral in Fock exchange is expressed as
        $(ik|jl)=\Sigma_{a,b}C^{a}_{ij}V_{ab}C^{b}_{kl}$, where
        $V_{ab}=(P_{a}|P_{b})$ is a double-center integral. Smaller values of
        the V matrix can be truncated to accelerate calculation. The larger the
        threshold is, the faster the calculation and the lower the accuracy. A
        relatively safe choice of the value is 0, i.e. no truncation.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="exx_dm_threshold">exx_dm_threshold</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The Fock exchange can be expressed as
        $\Sigma_{k,l}(ik|jl)D_{kl}$ where D is the density matrix. Smaller
        values of the density matrix can be truncated to accelerate calculation.
        The larger the threshold is, the faster the calculation and the lower
        the accuracy. A relatively safe choice of the value is 1d-4.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="exx_schwarz_threshold">exx_schwarz_threshold</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: In practice the four-center integrals are
        sparse, and using Cauchy-Schwartz inequality, we can find an upper bound
        of each integral before carrying out explicit evaluations. Those that
        are smaller than exx_schwarz_threshold will be truncated. The larger the
        threshold is, the faster the calculation and the lower the accuracy. A
        relatively safe choice of the value is 1d-5.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="exx_cauchy_threshold">exx_cauchy_threshold</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: In practice the Fock exchange matrix is
        sparse, and using Cauchy-Schwartz inequality, we can find an upper bound
        of each matrix element before carrying out explicit evaluations. Those
        that are smaller than exx_cauchy_threshold will be truncated. The larger
        the threshold is, the faster the calculation and the lower the accuracy.
        A relatively safe choice of the value is 1d-7.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="exx_ccp_threshold">exx_ccp_threshold</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: It is related to the cutoff of on-site
        Coulomb potentials, currently not used.
      </li>
      <li><strong>Default</strong>: 1e-8</li>
    </ul>
    <h4 id="exx_ccp_rmesh_times">exx_ccp_rmesh_times</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This parameter determines how many times
        larger the radial mesh required for calculating Columb potential is to
        that of atomic orbitals. For HSE1, setting it to 1 is enough. But for
        PBE0, a much larger number must be used.
      </li>
      <li><strong>Default</strong>: 10</li>
    </ul>
    <h4 id="exx_distribute_type">exx_distribute_type</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: When running in parallel, the evaluation
        of Fock exchange is done by distributing atom pairs on different
        threads, then gather the results. exx_distribute_type governs the
        mechanism of distribution. Available options are <code>htime</code>,
        <code>order</code>, <code>kmean1</code> and <code>kmeans2</code>.
        <code>order</code> is where atom pairs are simply distributed by their
        orders. <code>hmeans</code> is a distribution where the balance in time
        is achieved on each processor, hence if the memory is sufficient, this
        is the recommended method. <code>kmeans1</code> and
        <code>kmeans2</code> are two methods where the k-means clustering method
        is used to reduce memory requirement. They might be necessary for very
        large systems.
      </li>
      <li><strong>Default</strong>: <code>htime</code></li>
    </ul>
    <h4 id="exx_opt_orb_lmax">exx_opt_orb_lmax</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: See also the entry
        <a href="#exx_hybrid_type">exx_hybrid_type</a>. This parameter is only
        relevant when exx_hybrid_type=<code>opt_orb</code>. The radial part of
        opt-ABFs are generated as linear combinations of spherical Bessel
        functions. exx_opt_orb_lmax gives the maximum l of the spherical Bessel
        functions. A reasonable choice is 2.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="exx_opt_orb_ecut">exx_opt_orb_ecut</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: See also the entry
        <a href="#exx_hybrid_type">exx_hybrid_type</a>. This parameter is only
        relevant when exx_hybrid_type=<code>opt_orb</code>. A plane wave basis
        is used to optimize the radial ABFs. This parameter thus gives the
        cut-off of plane wave expansion, in Ry. A reasonable choice is 60.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="exx_opt_orb_tolerence">exx_opt_orb_tolerence</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: See also the entry
        <a href="#exx_hybrid_type">exx_hybrid_type</a>. This parameter is only
        relevant when exx_hybrid_type=<code>opt_orb</code>.
        exx_opt_orb_tolerence determines the threshold when solving for the
        zeros of spherical Bessel functions. A reasonable choice is 1e-12.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h3 id="moleculardynamics">Molecular dynamics</h3>
    <p>
      This part of variables are used to control the molecular dynamics
      calculations.
    </p>
    <h4 id="md_type">md_type</h4>
    <ul>
      <li>
        <p><strong>Type</strong>: Integer</p>
      </li>
      <li>
        <p><strong>Description</strong>: control the ensemble to run md.</p>
      </li>
      <li><p>-1: FIRE method to relax;</p></li>
      <li><p>0: NVE ensemble;</p></li>
      <li><p>1: NVT ensemble with Nose Hoover Chain;</p></li>
      <li><p>2: NVT ensemble with Langevin method;</p></li>
      <li><p>3: NVT ensemble with Anderson thermostat;</p></li>
      <li>
        <p>4: MSST method;</p>
        <p>
          <strong
            >_Note: when md_type is set to 1, md_tfreq is required to stablize
            temperature. It is an empirical parameter whose value is
            system-dependent, ranging from 1/(40*md_dt) to 1/(100*md_dt). An
            improper choice of its value might lead to failure of job._</strong
          >
        </p>
      </li>
      <li>
        <p><strong>Default</strong>: 1</p>
      </li>
    </ul>
    <h4 id="md_nstep">md_nstep</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>: the total number of md steps.</li>
      <li><strong>Default</strong>: 10</li>
    </ul>
    <h4 id="md_ensolver">md_ensolver</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li><strong>Description</strong>: choose the energy solver for MD.</li>
      <li>FP: First-Principles MD;</li>
      <li>LJ: Leonard Jones potential;</li>
      <li>DP: DeeP potential;</li>
      <li><strong>Default</strong>: FP</li>
    </ul>
    <h4 id="md_restart">md_restart</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li><strong>Description</strong>: to control whether restart md.</li>
      <li>0: When set to 0, ABACUS will calculate md normolly.</li>
      <li>
        1: When set to 1, ABACUS will calculate md from last step in your test
        before.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="md_dt">md_dt</h4>
    <ul>
      <li><strong>Type</strong>: Double</li>
      <li>
        <strong>Description</strong>: This is the time step(fs) used in md
        simulation .
      </li>
      <li><strong>Default</strong>: 1.0</li>
    </ul>
    <h4 id="md_tfirstmd_tlast">md_tfirst &amp; md_tlast</h4>
    <ul>
      <li><strong>Type</strong>: Double</li>
      <li>
        <strong>Description</strong>: This is the temperature (K) used in md
        simulation, md_tlast`s default value is md_tfirst. If md_tlast is set to
        be different from md_tfirst, ABACUS will automatically change the
        temperature from md_tfirst to md_tlast.
      </li>
      <li><strong>Default</strong>: No default</li>
    </ul>
    <h4 id="md_dumpfreq">md_dumpfreq</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>:This is the frequence to dump md
        information.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="md_restartfreq">md_restartfreq</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>:This is the frequence to output restart
        information.
      </li>
      <li><strong>Default</strong>: 5</li>
    </ul>
    <h4 id="md_seed">md_seed</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>md_seed &lt; 0: No srand() in MD initialization.</li>
      <li>md_seed &gt;= 0: srand(md_seed) in MD initialization.</li>
      <li><strong>Default</strong>: -1</li>
    </ul>
    <h4 id="md_tfreq">md_tfreq</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li><strong>Description</strong>:</li>
      <li>
        When md_type = 1, md_tfreq controls the frequency of the temperature
        oscillations during the simulation. If it is too large, the temperature
        will fluctuate violently; if it is too small, the temperature will take
        a very long time to equilibrate with the atomic system.
      </li>
      <li>
        When md_type = 3, md_tfreq*md_dt is the collision probability in
        Anderson method.
      </li>
      <li>
        If md_tfreq is not set in INPUT, md_tfreq will be autoset to be
        1/40/md_dt.
      </li>
      <li><strong>Default</strong>: 1/40/md_dt</li>
    </ul>
    <h4 id="md_mnhc">md_mnhc</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>: Number of Nose-Hoover chains.</li>
      <li><strong>Default</strong>: 4</li>
    </ul>
    <h4 id="lj_rcut">lj_rcut</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Cut-off radius for Leonard Jones potential
        (angstrom).
      </li>
      <li><strong>Default</strong>: 8.5 (for He)</li>
    </ul>
    <h4 id="lj_epsilon">lj_epsilon</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The value of epsilon for Leonard Jones
        potential (eV).
      </li>
      <li><strong>Default</strong>: 0.01032 (for He)</li>
    </ul>
    <h4 id="lj_sigma">lj_sigma</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The value of sigma for Leonard Jones
        potential (angstrom).
      </li>
      <li><strong>Default</strong>: 3.405 (for He)</li>
    </ul>
    <h4 id="msst_direction">msst_direction</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: the direction of shock wave for MSST.
      </li>
      <li><strong>Default</strong>: 2 (z direction)</li>
    </ul>
    <h4 id="msst_vel">msst_vel</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: the velocity of shock wave ($\AA$/fs) for
        MSST.
      </li>
      <li><strong>Default</strong>: 0.0</li>
    </ul>
    <h4 id="msst_vis">msst_vis</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: artificial viscosity (mass/length/time)
        for MSST.
      </li>
      <li><strong>Default</strong>: 0.0</li>
    </ul>
    <h4 id="msst_tscale">msst_tscale</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: reduction in initial temperature (0~1)
        used to compress volume in MSST.
      </li>
      <li><strong>Default</strong>: 0.01</li>
    </ul>
    <h4 id="msst_qmass">msst_qmass</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Inertia of extended system variable. Used
        only when md_type is 4, you should set a number which is larger than 0.
        Note that Qmass of NHC is set by md_tfreq.
      </li>
      <li><strong>Default</strong>: No default</li>
    </ul>
    <h4 id="md_damp">md_damp</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: damping parameter (fs) used to add force
        in Langevin method.
      </li>
      <li><strong>Default</strong>: 1.0</li>
    </ul>
    <h3 id="dftucorrection">DFT+U correction</h3>
    <p>
      This part of variables are used to control DFT+U correlated parameters
    </p>
    <h4 id="dft_plus_u">dft_plus_u</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 1, ABCUS will calculate plus U
        correction, which is especially important for correlated electron.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="orbital_corr">orbital_corr</h4>
    <ul>
      <li><strong>Type</strong>: Int</li>
      <li>
        <strong>Description</strong>: $l_1,l_2,l_3,\ldots$ for atom type 1,2,3
        respectively.(usually 2 for d electrons and 3 for f electrons) .Specify
        which orbits need plus U correction for each atom. If set to -1, the
        correction would not be calculate for this atom.
      </li>
      <li><strong>Default</strong>: None</li>
    </ul>
    <h4 id="hubbard_u">hubbard_u</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Hubbard Coulomb interaction parameter
        U(ev) in plus U correction,which should be specified for each atom
        unless Yukawa potential is use. ABACUS use a simplified scheme which
        only need U and J for each atom.
      </li>
      <li><strong>Default</strong>: 0.0</li>
    </ul>
    <h4 id="hund_j">hund_j</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Hund exchange parameter J(ev) in plus U
        correction ,which should be specified for each atom unless Yukawa
        potential is use. ABACUS use a simplified scheme which only need U and J
        for each atom.
      </li>
      <li><strong>Default</strong>: 0.0</li>
    </ul>
    <h4 id="yukawa_potential">yukawa_potential</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: whether use the local screen Coulomb
        potential method to calculate the value of U and J. If this is set to 1,
        hubbard_u and hund_j do not need to be specified.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="omc">omc</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: whether turn on occupation matrix control
        method or not
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h3 id="vdwcorrection">vdW correction</h3>
    <p>
      This part of variables are used to control vdW-corrected related
      parameters.
    </p>
    <h4 id="vdw_method">vdw_method</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: If set to d2 ,d3_0 or d3_bj, ABACUS will
        calculate corresponding vdW correction, which is DFT-D2, DFT-D3(0) or
        DFTD3(BJ) method. And this correction includes energy and forces.
        <code>none</code> means that no vdW-corrected method has been used.
      </li>
      <li><strong>Default</strong>: none</li>
    </ul>
    <h4 id="vdw_s6">vdw_s6</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This scale factor is to optimize the
        interaction energy deviations. For DFT-D2, it is found to be 0.75 (PBE),
        1.2 (BLYP), 1.05 (B-P86), 1.0 (TPSS), and 1.05 (B3LYP). For DFT-D3,
        recommended values of this parameter with different DFT functionals can
        be found on the
        <a
          href="https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3"
          >webpage</a
        >. The default values of this parameter in ABACUS is available for PBE.
        This variable will be set to default, if no vdW-corrected method has
        been used.
      </li>
      <li>
        <strong>Default</strong>: 0.75 if vdw_method is chosen to be d2; 1.0 if
        vdw_method is chosen to be d3_0 or d3_bj
      </li>
    </ul>
    <h4 id="vdw_s8">vdw_s8</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This scale factor is only the parameter of
        DFTD3 approachs including D3(0) and D3(BJ). Recommended values of this
        parameter with different DFT functionals can be found on the
        <a
          href="https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3"
          >webpage</a
        >. The default values of this parameter in ABACUS is available for PBE.
        This variable will be set to default, if no vdW-corrected method has
        been used.
      </li>
      <li>
        <strong>Default</strong>: 0.722 if vdw_method is chosen to be d3_0;
        0.7875 if vdw_method is chosen to be d3_bj
      </li>
    </ul>
    <h4 id="vdw_a1">vdw_a1</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This damping function parameter is only
        the parameter of DFT-D3 approachs including D3(0) and D3(BJ).
        Recommended values of this parameter with different DFT functionals can
        be found on the
        <a
          href="https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3"
          >webpage</a
        >. The default values of this parameter in ABACUS is available for PBE.
        This variable will be set to default, if no vdW-corrected method has
        been used.
      </li>
      <li>
        <strong>Default</strong>: 1.217 if vdw_method is chosen to be d3_0;
        0.4289 if vdw_method is chosen to be d3_bj
      </li>
    </ul>
    <h4 id="vdw_a2">vdw_a2</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This damping function arameter is only the
        parameter of DFT-D3(BJ) approach. Recommended values of this parameter
        with different DFT functionals can be found on the
        <a
          href="https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3"
          >webpage</a
        >. The default values of this parameter in ABACUS is available for PBE.
        This variable will be set to default, if no vdW-corrected method has
        been used.
      </li>
      <li>
        <strong>Default</strong>: 1.0 if vdw_method is chosen to be d3_0; 4.4407
        if vdw_method is chosen to be d3_bj
      </li>
    </ul>
    <h4 id="vdw_d">vdw_d</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The variable is to control the dumping
        speed of dumping function of DFT-D2.
      </li>
      <li><strong>Default</strong>: 20</li>
    </ul>
    <h4 id="vdw_abc">vdw_abc</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: The variable is to control the calculation
        of three-body term of DFT-D3 approachs, including D3(0) and D3(BJ). If
        set to 1, ABACUS will calculate three-body term, otherwise, the
        three-body term is not included.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="vdw_c6_file">vdw_C6_file</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This variable which is useful only when
        set vdw_method to d2 specifies the name of each elemetent's $C_6$
        Parameters file. If you dont setup this, ABACUS will use the default
        $C_6$ Parameters stored in the programme already. We've stored elements
        from 1_H to 86_Rn. Otherwise, if you want to use some new $C_6$
        Parameters, you should provide a file contained all the $C_6$ Parameters
        ordered by periodic table of elements, from 1_H to the last elements you
        want.
      </li>
      <li><strong>Default</strong>: default</li>
    </ul>
    <h4 id="vdw_c6_unit">vdw_C6_unit</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This variable which is useful only when
        set vdw_method to d2 specifies unit of $C_6$ Parameters. Two kinds of
        unit is available: <code>JÂ·nm6/mol</code> (means JÂ·nm^{6}/mol) and
        eVA(means eVÂ·Angstrom)
      </li>
      <li><strong>Default</strong>: Jnm6/mol</li>
    </ul>
    <h4 id="vdw_r0_file">vdw_R0_file</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This variable which is useful only when
        set vdw_method to d2 specifies the name of each elemetent's $R_0$
        Parameters file. If you don't setup this, ABACUS will use the default
        $R_0$ Parameters stored in the programme already. We've stored elements
        from 1_H to 86_Rn. Otherwise, if you want to use some new $R_0$
        Parameters, you should provide a file contained all the $R_0$ Parameters
        ordered by periodic table of elements, from 1_H to the last elements you
        want.
      </li>
      <li><strong>Default</strong>: default</li>
    </ul>
    <h4 id="vdw_r0_unit">vdw_R0_unit</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This variable which is useful only when
        set vdw_method to d2 specifies unit of $R_0$ Parameters. Two kinds of
        unit is available: A(means Angstrom) and Bohr.
      </li>
      <li><strong>Default</strong>: A</li>
    </ul>
    <h4 id="vdw_model">vdw_model</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: To calculate the periodic structure, you
        can assign the number of lattice cells calculated. This variable
        specifies the kind of model to assign. If set to period, ABACUS will
        calculate a cubic periodic structure as assigned in vdw_period. If set
        to radius, ABACUS will calculate a cubic periodic structure containing a
        sphere, whose radius is vdw_radius and centre is origin point.
      </li>
      <li><strong>Default</strong>: radius</li>
    </ul>
    <h4 id="vdw_radius">vdw_radius</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: If vdw_model is set to radius, this
        variable specifies the radius of the calculated sphere. For DFT-D2, the
        default value is 56.6918 ,while it is 95 for DFT-D3. This variable will
        be set to default, if no vdW-corrected method has been used.
      </li>
      <li>
        <strong>Default</strong>: 56.6918 if vdw_method is chosen to be d2; 95
        if vdw_method is chosen to be d3_0 or d3_bj
      </li>
    </ul>
    <h4 id="vdw_radius_unit">vdw_radius_unit</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: If vdw_model is set to radius, this
        variable specifies the unit of vdw_radius. Two kinds of unit is
        available: A(means Angstrom) and Bohr.
      </li>
      <li><strong>Default</strong>: Bohr</li>
    </ul>
    <h4 id="vdw_cn_radius">vdw_cn_radius</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: This cutoff is chosen for the calculation
        of the coordination number (CN) in DFT-D3 approachs, including D3(0) and
        D3(BJ).
      </li>
      <li><strong>Default</strong>: 40.0</li>
    </ul>
    <h4 id="vdw_cn_radius_unit">vdw_cn_radius_unit</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: This variable specifies the unit of
        vdw_cn_radius. Two kinds of unit is available: A(means Angstrom) and
        Bohr.
      </li>
      <li><strong>Default</strong>: Bohr</li>
    </ul>
    <h4 id="vdw_period">vdw_period</h4>
    <ul>
      <li><strong>Type</strong>: Int Int Int</li>
      <li>
        <strong>Description</strong>: If vdw_model is set to period, these
        variables specify the number of x, y and z periodic.
      </li>
      <li><strong>Default</strong>: 3 3 3</li>
    </ul>
    <h3 id="berryphaseandwannier90interface">
      Berry phase and wannier90 interface
    </h3>
    <p>
      This part of variables are used to control berry phase and wannier90
      interfacae parameters.
    </p>
    <h4 id="berry_phase">berry_phase</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: 1, calculate berry phase; 0, no calculate
        berry phase.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="gdir">gdir</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>
        1: calculate the polarization in the direction of the lattice vector a_1
        that is defined in STRU file.
      </li>
      <li>
        2: calculate the polarization in the direction of the lattice vector a_2
        that is defined in STRU file.
      </li>
      <li>
        3: calculate the polarization in the direction of the lattice vector a_3
        that is defined in STRU file.
      </li>
      <li><strong>Default</strong>: 3</li>
    </ul>
    <h4 id="towannier90">towannier90</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: 1, generate files for wannier90 code; 0,
        no generate.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="nnkpfile">nnkpfile</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li>
        <strong>Description</strong>: the file name when you run âwannier90 -pp
        …â.
      </li>
      <li><strong>Default</strong>: seedname.nnkp</li>
    </ul>
    <h4 id="wannier_spin">wannier_spin</h4>
    <ul>
      <li><strong>Type</strong>: String</li>
      <li><strong>Description</strong>: If nspin is set to 2,</li>
      <li>up: calculate spin up for wannier function.</li>
      <li>down: calculate spin down for wannier function.</li>
      <li><strong>Default</strong>: up</li>
    </ul>
    <h3 id="tddfttimedependentdensityfunctionaltheory">
      TDDFT: time dependent density functional theory
    </h3>
    <h4 id="tddft">tddft</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>
        1: calculate the real time time dependent density functional theory
        (TDDFT).
      </li>
      <li>0: do not calculate TDDFT.</li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="td_scf_thr">td_scf_thr</h4>
    <ul>
      <li><strong>Type</strong>: Double</li>
      <li>
        <strong>Description</strong>: Accuracy of electron convergence when
        doing time-dependent evolution.
      </li>
      <li><strong>Default</strong>: 1e-9</li>
    </ul>
    <h4 id="td_dt">td_dt</h4>
    <ul>
      <li><strong>Type</strong>: Double</li>
      <li>
        <strong>Description</strong>: Time-dependent evolution time step. (fs)
      </li>
      <li><strong>Default</strong>: 0.02</li>
    </ul>
    <h4 id="td_force_dt">td_force_dt</h4>
    <ul>
      <li><strong>Type</strong>: Double</li>
      <li>
        <strong>Description</strong>: Time-dependent evolution force changes
        time step. (fs)
      </li>
      <li><strong>Default</strong>: 0.02</li>
    </ul>
    <h4 id="td_vext">td_vext</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>1: add a laser material interaction (extern laser field).</li>
      <li>0: no extern laser field.</li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="td_vext_dire">td_vext_dire</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>1: the direction of external light field is along x axis.</li>
      <li>2: the direction of external light field is along y axis.</li>
      <li>3: the direction of external light field is along z axis.</li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="td_timescale">td_timescale</h4>
    <ul>
      <li><strong>Type</strong>: Double</li>
      <li>
        <strong>Description</strong>: Time range of external electric field
        application. (fs)
      </li>
      <li><strong>Default</strong>: 0.5</li>
    </ul>
    <h4 id="td_vexttype">td_vexttype</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>1: Gaussian-type light field.</li>
      <li>2: Delta function form light field.</li>
      <li>3: Trigonometric function form light field.</li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="td_vextout">td_vextout</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>1: Output external electric field.</li>
      <li>0: do not Output external electric field.</li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="td_dipoleout">td_dipoleout</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li><strong>Description</strong>:</li>
      <li>1: Output dipole.</li>
      <li>0: do not Output dipole.</li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="ocp">ocp</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: option for choose whether calcualting
        constrained DFT or not. Only used for TDDFT.
      </li>
      <li><strong>Default</strong>:0</li>
    </ul>
    <h4 id="ocp_set">ocp_set</h4>
    <ul>
      <li><strong>Type</strong>: string</li>
      <li>
        <strong>Description</strong>: If ocp is true, the ocp_set is a string to
        set the number of occupancy, like 1 10 * 1 0 1 representing the 13 band
        occupancy, 12th band occupancy 0 and the rest 1, the code is parsing
        this string into an array through a regular expression.
      </li>
      <li><strong>Default</strong>:none</li>
    </ul>
    <h3 id="variablesusefulfordebugging">Variables useful for debugging</h3>
    <h4 id="nurse">nurse</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 1, the Hamiltonian matrix and S
        matrix in each iteration will be written in output.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="t_in_h">t_in_h</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 0, then kinetic term will not be
        included in obtaining the Hamiltonian.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="vl_in_h">vl_in_h</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 0, then local pseudopotential
        term will not be included in obtaining the Hamiltonian.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="vnl_in_h">vnl_in_h</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 0, then non-local
        pseudopotential term will not be included in obtaining the Hamiltonian.
      </li>
      <li><strong>Default</strong>: 1</li>
    </ul>
    <h4 id="test_force">test_force</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 1, then detailed components in
        forces will be written to output.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="test_stress">test_stress</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 1, then detailed components in
        stress will be written to output.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="colour">colour</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 1, output to terminal will have
        some color.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h3 id="electronicconductivities">Electronic conductivities</h3>
    <p>
      Frequency-dependent electronic conductivities can be calculated with
      Kubo-Greenwood formula[Phys. Rev. B 83, 235120 (2011)]. Onsager
      coefficiencies: $$L_{mn}(\omega)=(-1)^{m+n}\frac{2\pi
      e^2\hbar^2}{3m_e^2\omega\Omega}\
      \times\sum_{ij\alpha\mathbf{k}}W(\mathbf{k})\left(\frac{\epsilon_{i\mathbf{k}}+\epsilon_{j\mathbf{k}}}{2}-\mu\right)^{m+n-2}|
      \langle\Psi_{i\mathbf{k}}|\nabla_\alpha|\Psi_{j\mathbf{k}}\rangle|^2\
      \times[f(\epsilon_{i\mathbf{k}})-f(\epsilon_{j\mathbf{k}})]\delta(\epsilon_{j\mathbf{k}}-\epsilon_{i\mathbf{k}}-\hbar\omega).$$
      They can also computed by $j$-$j$ correlation function.
      $$L_{mn}=\frac{2e^{m+n-2}}{3\Omega\hbar\omega}\Im[\tilde{C}_{mn}(\omega)]\
      \tilde{C}_{mn}=\int_0^\infty C_{mn}(t)e^{-i\omega t}e^{-\frac{1}{2}(\Delta
      E)^2t^2}dt\ C_{mn}(t)=-2\theta(t)\Im\left{Tr\left[\sqrt{\hat
      f}\hat{j}_m(1-\hat{f})e^{i\frac{\hat{H}}{\hbar}t}\hat{j}_ne^{-i\frac{\hat{H}}{\hbar}t}\sqrt{\hat
      f}\right]\right},$$ where $j_1$ is electric flux and $j_2$ is thermal
      flux. Frequency-dependent electric conductivities:
      $\sigma(\omega)=L_{11}(\omega).$ Frequency-dependent thermal
      conductivities:
      $\kappa(\omega)=\frac{1}{e^2T}\left(L_{22}-\frac{L_{12}^2}{L_{11}}\right).$
      DC electric conductivities: $\sigma = \lim_{\omega\to 0}\sigma(\omega)$
      Thermal conductivities: $\kappa = \lim_{\omega\to 0}\kappa(\omega)$
    </p>
    <h4 id="cal_cond">cal_cond</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 1, electronic conductivities
        will be calculated. Only supported in calculations of SDFT and KSDFT_PW.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="cond_nche">cond_nche</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Chebyshev expansion orders for stochastic
        Kubo Greenwood. Only used when the calculation is SDFT.
      </li>
      <li><strong>Default</strong>: 20</li>
    </ul>
    <h4 id="cond_dw">cond_dw</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Frequency interval ($d\omega$) for
        frequency-dependent conductivities. The unit is eV.
      </li>
      <li><strong>Default</strong>: 0.1</li>
    </ul>
    <h4 id="cond_wcut">cond_wcut</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: Cutoff frequency for frequency-dependent
        conductivities. The unit is eV.
      </li>
      <li><strong>Default</strong>: 10.0</li>
    </ul>
    <h4 id="cond_wenlarge">cond_wenlarge</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: Control the t interval: dt =
        $\frac{\pi}{\omega_{cut}\times\omega enlarge}$
      </li>
      <li><strong>Default</strong>: 10</li>
    </ul>
    <h4 id="cond_fwhm">cond_fwhm</h4>
    <ul>
      <li><strong>Type</strong>: Integer</li>
      <li>
        <strong>Description</strong>: We use gaussian functions to approxiamte
        $\delta(E)\approx \frac{1}{\sqrt{2\pi}\Delta E}e^{-\frac{E^2}{2{\Delta
        E}^2}}$. FWHM for conductivities, $FWHM=2*\sqrt{2\ln2}\cdot \Delta E$.
        The unit is eV.
      </li>
      <li><strong>Default</strong>: 0.3</li>
    </ul>
    <h3 id="implicitsolvationmodel">Implicit solvation model</h3>
    <p>
      This part of variables are used to control the usage of implicit solvation
      model. This approach treats the solvent as a continuous medium instead of
      individual âexplicitâ solvent molecules, which means that the solute
      embedded in an implicit solvent and the average over the solvent degrees
      of freedom becomes implicit in the properties of the solvent bath.
    </p>
    <h4 id="imp_sol">imp_sol</h4>
    <ul>
      <li><strong>Type</strong>: Boolean</li>
      <li>
        <strong>Description</strong>: If set to 1, an implicit solvation
        correction is considered.
      </li>
      <li><strong>Default</strong>: 0</li>
    </ul>
    <h4 id="eb_k">eb_k</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The relative permittivity of the bulk
        solvent, 80 for water. Used only if <code>imp_sol</code> == true.
      </li>
      <li><strong>Default</strong>: 80</li>
    </ul>
    <h4 id="tau">tau</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: The effective surface tension parameter,
        which describes the cavitation, the dispersion, and the repulsion
        interaction between the solute and the solvent that are not captured by
        the electrostatic terms. The unit is $Ry/Bohr^{2}$.
      </li>
      <li><strong>Default</strong>: 1.0798e-05</li>
    </ul>
    <h4 id="sigma_k">sigma_k</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: We assume a diffuse cavity that is
        implicitly determined by the electronic structure of the solute.
        <code>sigma_k</code> is the parameter that describes the width of the
        diffuse cavity.
      </li>
      <li><strong>Default</strong>: 0.6</li>
    </ul>
    <h4 id="nc_k">nc_k</h4>
    <ul>
      <li><strong>Type</strong>: Real</li>
      <li>
        <strong>Description</strong>: It determines at what value of the
        electron density the dielectric cavity forms. The unit is $Bohr^{-3}$.
      </li>
      <li><strong>Default</strong>: 0.00037</li>
    </ul>
  </div>
</div>
